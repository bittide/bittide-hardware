-- SPDX-FileCopyrightText: 2022 Google LLC
--
-- SPDX-License-Identifier: Apache-2.0
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE ViewPatterns #-}

{- | Helper functions to do things like synthesis, place & route, bitstream
generation, programming and running hardware tests for the Bittide project.
This is realized by letting Vivado execute Tcl using the `vivado-hs` package.
Refer to @bittide-instances/src/Bittide/Instances/Hitl/README.md@ and
`Bittide.Hitl` for more information on the HITL test infrastructure.
-}
module Clash.Shake.Vivado (
  LocatedManifest (..),
  BoardPart (..),
  TclGlobPattern,
  decodeLocatedManifest,
  runSynthesis,
  runPlaceAndRoute,
  runBitstreamGen,
  runProbesFileGen,
  pollTestDone,
  programBitstream,
  runHitlTest,
  meetsTiming,
  meetsDrc,
) where

import Prelude

import Development.Shake (Action)
import Development.Shake.Extra (decodeFile)

import Bittide.Hitl
import Bittide.Instances.Hitl.Setup (demoRigInfo, knownFpgaIds)
import Bittide.Instances.Hitl.Utils.Vivado
import Clash.Driver.Manifest
import Clash.Prelude (BitPack (BitSize), Natural, natToNatural, pack)
import Clash.Shake.Extra (hexDigestFile)
import qualified Clash.Sized.Internal.BitVector as BitVector
import Control.Concurrent (threadDelay)
import Control.Concurrent.MVar (MVar, modifyMVar, newMVar)
import Control.Exception (Exception (displayException), SomeException, catch, try)
import Control.Monad.Extra (andM, forM, forM_, orM, unless, when)
import Control.Monad.Reader (runReaderT)
import Data.Containers.ListUtils (nubOrd)
import Data.Either (lefts, rights)
import Data.List (isInfixOf, isSuffixOf, sort, sortOn, (\\))
import Data.List.Extra (anySame, split, (!?))
import Data.Map.Strict (fromList, keys, mapKeys, toAscList)
import qualified Data.Map.Strict as Map
import Data.Maybe (fromJust, fromMaybe)
import Data.Set (Set)
import qualified Data.Set as Set
import Data.String.Interpolate (i, __i)
import Data.Text (unpack)
import System.Clock (Clock (Monotonic), TimeSpec, diffTimeSpec, getTime, toNanoSecs)
import System.Directory (createDirectoryIfMissing)
import System.Exit (ExitCode (..))
import System.FilePath (dropFileName, (</>))
import Text.Read (readMaybe)
import Vivado (TclException (..), VivadoHandle, execPrint_, with)
import Vivado.Tcl
import Vivado.VivadoM

-- | Satisfied if all actions result in 'False'
noneM :: (Monad m) => [m Bool] -> m Bool
noneM = fmap not . orM

-- | Whether a string occurs in a file
inFile :: String -> FilePath -> IO Bool
inFile msg path = do
  content <- readFile path
  pure $ (msg `isInfixOf` content)

{- | Read a timing summary or DRC report and determine whether it passed DRC
checks.
-}
meetsDrc :: FilePath -> IO Bool
meetsDrc path =
  noneM
    [ inFile "No report available as report_methodology has not been run prior." path
    , inFile "Critical Warning" path
    ]

-- | Read a timing summary and determine whether it met timing.
meetsTiming :: FilePath -> IO Bool
meetsTiming path =
  andM
    [ meetsDrc path -- for safety; users should use meetsDrc for useful error reporting
    , not <$> inFile "Timing constraints are not met" path
    ]

-- | Patterns compatible with https://www.tcl.tk/man/tcl8.6/TclCmd/glob.htm
type TclGlobPattern = String

-- TODO: Upstream
data LocatedManifest = LocatedManifest
  { lmPath :: FilePath
  -- ^ Path pointing to the manifest file itself
  , lmManifest :: Manifest
  -- ^ Manifest file corresponding to the one at 'lmPath'
  }

decodeLocatedManifest :: FilePath -> Action LocatedManifest
decodeLocatedManifest path = LocatedManifest path <$> decodeFile path

{- | Vivado board part or part. If a board part is set, Vivado will infer the
part on that board.
-}
data BoardPart
  = Board String
  | Part String

-- | Generate Tcl that sets the board part or part for the current project
mkBoardPartTcl :: BoardPart -> String
mkBoardPartTcl boardPart = case boardPart of
  (Board name) -> "set_property board_part " <> name <> " [current_project]"
  (Part name) -> "set_property part " <> name <> " [current_project]"

{- | Generates TCL that generates and reads Xilinx IP and reads constraints and
HDL files generated by Clash. The caller is responsible for starting synthesis
or simulation.
-}
execBaseTcl ::
  -- | Handle to a Vivado object that is to execute the Tcl.
  VivadoHandle ->
  -- | Where to create ip directory.
  FilePath ->
  -- | List of glob patterns to external HDL files.
  [TclGlobPattern] ->
  -- | Top entity directory
  LocatedManifest ->
  -- | Board part or part to synthesize for
  BoardPart ->
  -- | Path to tclConnector: a Tcl script that can parse Clash output and emit
  -- the correct commands for loading the design into Vivado
  FilePath ->
  IO ()
execBaseTcl v outputDir globPatterns LocatedManifest{lmPath} boardPart connector = do
  connectorDigest <- hexDigestFile connector
  lmPathDigest <- hexDigestFile lmPath
  let
    topEntityDir = dropFileName lmPath
    boardPartTcl = mkBoardPartTcl boardPart
    globTcl
      | null globPatterns = "" :: String
      | otherwise =
          [__i|
        set extra_hdl_files [list]
        \# We use file join to be able to retrieve environment variables
        \# from our paths
        set glob_patterns "#{unlines $ fmap (\p -> "[file join " <> p <> "]") globPatterns}"
        foreach pat $glob_patterns {
          puts "Adding files matching $pat"
          set extra_hdl_files [concat $extra_hdl_files [glob $pat]]
        }
        add_files $extra_hdl_files
        |]

  execPrint_
    v
    [__i|
    \# #{lmPath}: #{lmPathDigest}
    \# #{connector}: #{connectorDigest}
    set_msg_config -severity {CRITICAL WARNING} -new_severity ERROR
    source -notrace {#{connector}}
    file delete -force {#{outputDir </> "ip"}}
    file mkdir {#{outputDir </> "ip"}}
    clash::readMetadata {#{topEntityDir}}

    set hasIp [expr [llength [clash::GetAllTclIfaces {purposes createIp}]] > 0]

    if {${hasIp}} {
      create_project -in_memory
      #{boardPartTcl}
      set ips [clash::createIp -dir {#{outputDir </> "ip"}}]
      set ipFiles [get_property IP_FILE [get_ips $ips]]
      close_project
    }

    clash::readHdl
    #{boardPartTcl}
    #{globTcl}
    if {${hasIp}} {
      read_ip $ipFiles
      set_property GENERATE_SYNTH_CHECKPOINT false [get_files $ipFiles]
      generate_target {synthesis simulation} [get_ips $ips]
    }

    clash::readXdc {early normal late}
    set_property TOP $clash::topEntity [current_fileset]
  |]

runSynthesis ::
  -- | Directory to write logs and checkpoints to
  FilePath ->
  -- | Out of context?
  Bool ->
  -- | Board part or part to synthesize for. E.g., 'xcku040-ffva1156-2-e'.
  BoardPart ->
  -- | List of filepaths to XDC files
  [FilePath] ->
  -- | List of glob patterns to external HDL files.
  [TclGlobPattern] ->
  -- | Manifests of which the first is the top-level to synthesize
  LocatedManifest ->
  -- | Path to tclConnector: a Tcl script that can parse Clash output and emit
  -- the correct commands for loading the design into Vivado
  FilePath ->
  IO ()
runSynthesis
  outputDir
  outOfContext
  boardPart
  constraints
  globPatterns
  manifest@LocatedManifest{lmManifest}
  connector = with $ \v -> do
    execBaseTcl v outputDir globPatterns manifest boardPart connector

    constraintDigests <- unlines <$> mapM constraintDigest constraints
    putStrLn constraintDigests

    execCmd_ v "set_msg_config" ["-severity {CRITICAL WARNING}", "-new_severity ERROR"]
    forM_ constraints (\xdcPath -> execCmd v "read_xdc" ["-unmanaged {" <> xdcPath <> "}"])

    -- Synthesis
    execCmd_
      v
      "synth_design"
      [ "-name " <> unpack (topComponent lmManifest)
      , "-mode " <> if outOfContext then "outOfContext" else "default"
      ]
    createDirectoryIfMissing True $ outputDir </> "reports"
    createDirectoryIfMissing True $ outputDir </> "checkpoints"
    execCmd_
      v
      "report_methodology"
      ["-file {" <> outputDir </> "reports" </> "post_synth_methodology.rpt}"]
    execCmd_
      v
      "report_timing_summary"
      ["-file {" <> outputDir </> "reports" </> "post_synth_timing_summary.rpt}"]
    execCmd_
      v
      "report_utilization"
      ["-file {" <> outputDir </> "reports" </> "post_synth_util.rpt}"]
    execCmd_
      v
      "write_checkpoint"
      ["-force", "{" <> outputDir </> "checkpoints" </> "post_synth.dcp}"]

    -- Netlist
    createDirectoryIfMissing True $ outputDir </> "netlist"
    execCmd_
      v
      "write_verilog"
      ["-force", outputDir </> "netlist" </> "netlist.v"]
    execCmd_
      v
      "write_xdc"
      ["-no_fixed_only", "-force", outputDir </> "netlist" </> "netlist.xdc"]
   where
    constraintDigest path = do
      pathDigest <- hexDigestFile path
      pure [__i|\# #{path}: #{pathDigest}|]

runPlaceAndRoute :: FilePath -> IO ()
runPlaceAndRoute outputDir = with $ \v ->
  execPrint_
    v
    [__i|
    set_msg_config -severity {CRITICAL WARNING} -new_severity ERROR

    \# Pick up where synthesis left off
    open_checkpoint {#{outputDir </> "checkpoints" </> "post_synth.dcp"}}

    \# Run optimization & placement
    opt_design
    place_design
    phys_opt_design
    write_checkpoint -force {#{outputDir </> "checkpoints" </> "post_place.dcp"}}

    \# Routing
    route_design
    write_checkpoint -force {#{outputDir </> "checkpoints" </> "post_route.dcp"}}
    report_methodology -file {#{outputDir </> "reports" </> "post_route_methodology.rpt"}}
    report_timing_summary -file {#{outputDir </> "reports" </> "post_route_timing_summary.rpt"}}
    report_timing -sort_by group -max_paths 100 -path_type summary -file {#{outputDir </> "reports" </> "post_route_timing.rpt"}}

    report_clock_utilization -file {#{outputDir </> "reports" </> "post_route_clock_util.rpt"}}
    report_utilization       -file {#{outputDir </> "reports" </> "post_route_util.rpt"}}
    report_power             -file {#{outputDir </> "reports" </> "post_route_power.rpt"}}
    report_drc               -file {#{outputDir </> "reports" </> "post_route_drc.rpt"}}

    \# Generate netlist and constraints
    file mkdir {#{outputDir </> "netlist"}}
    write_verilog -force {#{outputDir </> "netlist" </> "netlist.v"}}
    write_xdc -no_fixed_only -force {#{outputDir </> "netlist" </> "netlist.xdc"}}
|]

runBitstreamGen :: FilePath -> IO ()
runBitstreamGen outputDir = with $ \v -> do
  execCmd_ v "set_msg_config" ["-severity {CRITICAL WARNING}", "-new_severity ERROR"]

  -- Pick up where netlist left off
  execPrint_
    v
    ("open_checkpoint {" <> outputDir </> "checkpoints" </> "post_route.dcp" <> "}")

  -- Generate bitstream
  execPrint_ v "set_property BITSTREAM.GENERAL.COMPRESS TRUE [current_design]"
  execPrint_ v ("write_bitstream -force {" <> outputDir </> "bitstream.bit" <> "}")

runProbesFileGen :: FilePath -> IO ()
runProbesFileGen outputDir = with $ \v -> do
  execPrint_ v "set_msg_config -severity {CRITICAL WARNING} -new_severity ERROR"

  -- Pick up where netlist left off
  execPrint_
    v
    ("open_checkpoint {" <> outputDir </> "checkpoints" </> "post_route.dcp" <> "}")

  -- Generate probes file
  execPrint_ v ("write_debug_probes -force {" <> outputDir </> "probes.ltx" <> "}")

{- | Attempts to find and return the ID of a hardware target referenced by a given
`HwTargetRef`. This is what Vivado seems to call the UID minus the vendor string.
-}
idFromHwTRef :: HwTargetRef -> FpgaId
idFromHwTRef (HwTargetByIndex ix) =
  fromMaybe
    ("The given index " <> show ix <> " is out of range for the list of known FPGA IDs")
    (knownFpgaIds !? fromIntegral ix)
idFromHwTRef (HwTargetById targetId _) = targetId

deviceInfoFromHwTRef :: HwTargetRef -> DeviceInfo
deviceInfoFromHwTRef (HwTargetByIndex ix) =
  fromMaybe
    ( error $ "The given index " <> show ix <> " is out of range for the list of known FPGA IDs"
    )
    (demoRigInfo !? fromIntegral ix)
deviceInfoFromHwTRef (HwTargetById _ d) = d

{- | Tries to find the hardware target with a specific FPGA ID in a given list of hardware targets.
Returns the FPGA ID wrapped in a `Left` on failure to find such a target.
-}
findHwTWithId :: FpgaId -> [HwTarget] -> Either FpgaId HwTarget
findHwTWithId fpgaId hwTs = do
  case filter ((== fpgaId) . idFromHwT) hwTs of
    [] -> Left fpgaId
    [hwT] -> Right hwT
    hwTs' -> error $ "Found multiple hardware targets with the same ID: " <> show hwTs'

{- | Attempts to resolve a given list of hardware target references and return a
`Map HwTargetRef HwTarget`. The available hardware targets on the connected
hardware servers are queried for a limited number of times and errors if the
requested targets cannot be found.
-}
resolveHwTRefs ::
  -- | Handle to a Vivado object that is to execute the Tcl.
  VivadoHandle ->
  [HwTargetRef] ->
  IO (Map.Map HwTargetRef HwTarget)
resolveHwTRefs v requestedHwTRefs = do
  let requestedIds = idFromHwTRef <$> requestedHwTRefs
  let
    go :: Int -> IO (Map.Map HwTargetRef HwTarget)
    go numTries = do
      foundTargets <- get_hw_targets v []
      printInfo foundTargets
      let matchingTargets = (`findHwTWithId` foundTargets) <$> requestedIds
      if null (lefts matchingTargets)
        then do
          pure $ fromList $ zip requestedHwTRefs (rights matchingTargets)
        else do
          putStrLn $
            "WARNING: The connected hardware servers did not host the requested "
              <> "hardware targets with IDs "
              <> show (lefts matchingTargets)
          if numTries < 0
            then error "Giving up."
            else do
              putStrLn "Retrying..."
              threadDelay 500000 -- In μs
              refresh_hw_server v []
              go (numTries - 1)
  go 10
 where
  printInfo foundTargets = do
    putStrLn $
      "The connected hardware servers host "
        <> show (length foundTargets)
        <> " hardware targets:"
    mapM_ (putStrLn . ('\t' :) . show) foundTargets
    let foundFpgaIds = idFromHwT <$> foundTargets
    when (sort foundFpgaIds /= sort knownFpgaIds) $
      putStrLn $
        "WARNING: The IDs of the hosted hardware targets do not match the known ones."
          <> "\n\tNot found but expected: "
          <> show (knownFpgaIds \\ foundFpgaIds)
          <> "\n\tFound but unexpected: "
          <> show (foundFpgaIds \\ knownFpgaIds)

programBitstream ::
  -- | Directory where the bitstream files are located
  FilePath ->
  -- | References to the hardware targets to program
  [HwTargetRef] ->
  -- | Hardware server URL
  String ->
  -- | Flag indicating if the target has a probes file. If true, the probes file
  -- is programmed alongside the bitstream.
  Bool ->
  IO ()
programBitstream outputDir hwTRefs url hasProbesFile = with $ \v -> do
  putStrLn "Starting programming of given hardware targets..."
  if null hwTRefs
    then putStrLn "WARNING: Not programming as no hardware target references were given."
    else do
      execCmd_ v "set_msg_config" ["-severity {CRITICAL WARNING}", "-new_severity ERROR"]
      execCmd_ v "open_hw_manager" []
      execCmd_ v "connect_hw_server" ["-url " <> url]
      refToHwTMap <- resolveHwTRefs v hwTRefs
      let hwTs = nubOrd $ Map.elems refToHwTMap
      forM_ hwTs $ \hwT -> do
        openHwTarget v hwT
        execCmd_
          v
          "set_property"
          [ "PROGRAM.FILE"
          , embrace (outputDir </> "bitstream.bit")
          , "[current_hw_device]"
          ]
        execCmd_
          v
          "set_property"
          [ "PROBES.FILE"
          , if hasProbesFile then embrace (outputDir </> "probes.ltx") else "{}"
          , "[current_hw_device]"
          ]
        -- Program the device and close properly
        _ <- program_hw_devices v ["[current_hw_device]"]
        refresh_hw_device v ["[current_hw_device]"]

data VioProbeInfo = VioProbeInfo
  { probeName :: String
  , probeType :: String
  , probeWidth :: String
  }

{- | Verifies whether the bitstream programmed on the current hardware target
includes a VIO IP core that is configured as required by this HITL framework.
See `Bittide.Hitl` for details.

Make sure that the `PROBES.FILE` property is set for the `current_hw_device`
and that `refresh_hw_device` has been run afterwards.
-}
verifyHitlVio :: VivadoHandle -> Natural -> IO ()
verifyHitlVio v paramBitSize = do
  vioProbes <- get_hw_probes v ["-of_objects [get_hw_vios]", "*vioHitlt/*"]
  let unexpectedProbes =
        [ show probe
        | probe <- vioProbes
        , not (any (`isSuffixOf` show probe) requiredProbeSimpleNames)
        ]
       where
        requiredProbeSimpleNames = map (last . split (== '/') . probeName) requiredProbes
  unless (null unexpectedProbes) $ do
    putStrLn "WARNING: Encountered unexpected HITL VIO probes, they will be ignored:"
    mapM_ (putStrLn . ('\t' :)) unexpectedProbes
  mapM_ (`verifyHitlProbe` vioProbes) requiredProbes
 where
  requiredProbes =
    [ VioProbeInfo "*vioHitlt/probe_test_start" "vio_output" "1"
    , VioProbeInfo "*vioHitlt/probe_test_done" "vio_input" "1"
    , VioProbeInfo "*vioHitlt/probe_test_success" "vio_input" "1"
    ]
      <> [ VioProbeInfo "*vioHitlt/probe_test_data" "vio_output" (show paramBitSize)
         | paramBitSize /= 0
         ]
  verifyHitlProbe :: VioProbeInfo -> [HwProbe] -> IO ()
  verifyHitlProbe VioProbeInfo{..} vioProbes = do
    let simpleName = last (split (== '/') probeName)
    let probe = case filter (('/' : simpleName) `isSuffixOf`) (show <$> vioProbes) of
          [p] -> p
          ps ->
            error $
              "Exactly one probe named '"
                <> probeName
                <> "' "
                <> "must be present but "
                <> show (length ps)
                <> " were found."
    execCmd_
      v
      "set"
      [ simpleName
      , "[get_hw_probes -of_objects [get_hw_vios] " <> probeName <> "]"
      ]
    typeProp <- execCmd v "get_property" ["type", "$" <> simpleName]
    unless (typeProp == probeType) $
      error $
        "Probe '"
          <> probe
          <> "' must have type "
          <> probeType
          <> " but has '"
          <> typeProp
          <> "'."
    widthProp <- execCmd v "get_property" ["width", "$" <> simpleName]
    unless (widthProp == probeWidth) $
      error $
        "Probe '" <> probe <> "' must have width " <> probeWidth <> " but it is " <> widthProp

{- | Observed instances of property CELL_NAME of an hw_ila object include:
- "Bittide_Instances_Hitl_FullMeshSwCc_fullMeshSwCcTest_callistoClockControlWithIla_callistoResult/ilaPlot/ilaPlot"
- "instructionBus/dataBus"

This short name should return "ilaPlot" and "instructionBus" for
those examples respectively. Could be improved, see
https://github.com/bittide/bittide-hardware/issues/530
-}
getCurrentIlaShortName :: VivadoHandle -> IO String
getCurrentIlaShortName v = do
  ilaCellName <- execCmd v "get_property" ["CELL_NAME", "[current_hw_ila]"]
  pure $
    fromMaybe
      (error $ "Determining short name failed for ILA with CELL_NAME " <> ilaCellName)
      (reverse (split (== '/') ilaCellName) !? 1)

{- | Verify hardware ILAs. Verification should be performed before the `HwIla`
objects are used for the first time.
-}
verifyHwIlas :: VivadoHandle -> IO ()
verifyHwIlas v = do
  -- TODO either use or remove the Tcl dictionary
  execPrint_
    v
    [__i|
    \# Create a list of dictionaries where each dictionary corresponds to one ILA.
    \# Each dictionary has the following keys:
    \#   name          : short name of the ILA
    \#   cell_name     : name of the cell the ILA is in
    \#   trigger_probe : name of the trigger probe
    \#   capture_probe : name of the capture probe
    \#   data_probes   : list of names of all other probes
    proc get_ila_dicts {} {
        set ila_dicts {}

        set hw_ilas [get_hw_ilas -quiet]
        set ila_count [llength $hw_ilas]
        if {$ila_count == 0} {
            puts "\nNo ILAs in design"
            return {}
        }

        puts "\nFound $ila_count ILAs:"
        foreach hw_ila $hw_ilas {
            set ila_dict {}

            \# The short name is the name of the module the ILA is in. For example a
            \# cell named `fullMeshSwCcTest/ilaPlot/ila_inst` will give the short
            \# name `ilaPlot`.
            set cell_name [get_property CELL_NAME $hw_ila]
            set before_last [expr [string last / $cell_name] - 1]
            set module_name [string range $cell_name 0 $before_last]
            set after_second_to_last [expr [string last / $module_name] + 1]
            set short_name [string range $cell_name $after_second_to_last $before_last]
            dict set ila_dict name $short_name
            dict set ila_dict cell_name $cell_name

            \# Get trigger probe and verify it conforms with ILA framework
            set trigger_probe [get_hw_probes -of_objects $hw_ila */trigger*]
            set trigger_probe_count [llength $trigger_probe]
            if {$trigger_probe_count != 1} {
                set err_msg "Exactly one probe named 'trigger*' must be present, "
                append err_msg "but $trigger_probe_count were found" \n [all_probe_names_msg]
                error $err_msg
            } elseif {[get_property is_trigger $trigger_probe] != 1} {
                set probe_name_short [get_property name.short $trigger_probe]
                set err_msg "Probe '$probe_name_short' should have probeType "
                append err_msg {Trigger or DataAndTrigger} \n [all_probe_names_msg]
                error $err_msg
            } elseif {[get_property width $trigger_probe] != 1} {
                set probe_name_short [get_property name.short $trigger_probe]
                set err_msg "Probe '$probe_name_short' must have a width of 1 bit\n"
                append err_msg [all_probe_names_msg]
                error $err_msg
            } else {
                dict set ila_dict trigger_probe [get_property name $trigger_probe]
            }

            \# Get capture probe and verify it conforms with ILA framework
            set capture_probe [get_hw_probes -of_objects $hw_ila */capture*]
            set capture_probe_count [llength $capture_probe]
            if {$capture_probe_count != 1} {
                set err_msg {Exactly one probe named 'capture*' must be present, }
                append err_msg "but $capture_probe_count were found" \n [all_probe_names_msg]
                error $err_msg
            } elseif {[get_property is_trigger $capture_probe] != 1} {
                set probe_name_short [get_property name.short $capture_probe]
                set err_msg "Probe '$probe_name_short' should have probeType "
                append err_msg {Trigger or DataAndTrigger} \n [all_probe_names_msg]
                error $err_msg
            } elseif {[get_property width $capture_probe] != 1} {
                set probe_name_short [get_property name.short $capture_probe]
                set err_msg "Probe '$probe_name_short' must have a width of 1 bit\n"
                append err_msg [all_probe_names_msg]
                error $err_msg
            } else {
                dict set ila_dict capture_probe [get_property name $capture_probe]
            }

            \# Get all data probes and verify each conforms with ILA framework
            set all_probes [get_hw_probes -of_objects $hw_ila]
            if {[llength $all_probes] < 3} {
                set err_msg "ILA '$short_name' has no data probes, at least 1 "
                append err_msg {data probe is required} \n [all_probe_names_msg]
                error $err_msg
            }
            dict set ila_dict data_probes [list]
            foreach probe $all_probes {
                if {$probe eq $trigger_probe || $probe eq $capture_probe} {
                    continue
                } elseif {[get_property is_data $probe] != 1} {
                    set probe_name_short [get_property name.short $probe]
                    set err_msg "Probe '$probe_name_short' should have probeType "
                    append err_msg {Data or DataAndTrigger} \n [all_probe_names_msg]
                    error $err_msg
                } else {
                    dict update ila_dict data_probes probe_list {
                        lappend probe_list [get_property name $probe]
                    }
                }
            }
            lappend ila_dicts $ila_dict

            \# Print all ILA probes
            puts "ILA $short_name with probes:"
            set probe_name_short [get_property name.short $trigger_probe]
            puts "\t$probe_name_short"
            set probe_name_short [get_property name.short $capture_probe]
            puts "\t$probe_name_short"
            foreach probe_name [dict get $ila_dict data_probes] {
                set idx_start [expr {[string first / $probe_name] + 1}]
                set probe_name_short [string range $probe_name $idx_start end]
                puts "\t$probe_name_short"
            }
        }
        return $ila_dicts
    }
  |]
  execCmd_ v "set" ["ila_dicts", "[get_ila_dicts]"]

{- | Waits (with a timeout) until a HITL test case is finished by probing
the probe_test_done probe. Returns whether the test case was successful.
-}
waitTestCaseEnd ::
  VivadoHandle -> HitlTestCase (HwTarget, DeviceInfo) a b -> FilePath -> IO ExitCode
waitTestCaseEnd v HitlTestCase{..} probesFilePath = do
  startTime <- getTime Monotonic
  let calcTimeSpentMs = (`div` 1000000) . toNanoSecs . diffTimeSpec startTime <$> getTime Monotonic
  exitCodes <- forM (keys parameters) $ \(hwT, _) -> do
    openHwTarget v hwT
    execCmd_ v "set_property" ["PROBES.FILE", embrace probesFilePath, "[current_hw_device]"]
    pollTestDone startTime testTimeoutMs v hwT

  -- Print summary of test case
  timeSpentMs <- calcTimeSpentMs
  putStrLn $
    "HITL test case'"
      <> name
      <> "' passed on "
      <> show (length (filter (== ExitSuccess) exitCodes))
      <> " out of "
      <> show (length exitCodes)
      <> " hardware targets in "
      <> show timeSpentMs
      <> "ms."
  pure (maximum exitCodes)
 where
  -- \| Timeout specifying how long we should wait for a test to finish before
  -- considering it a failed test.
  -- TODO: Allow the user to specify the timeout for a test.
  testTimeoutMs = 60000 :: Integer

pollTestDone :: TimeSpec -> Integer -> VivadoHandle -> HwTarget -> IO ExitCode
pollTestDone startTime testTimeoutMs v hwT = do
  refresh_hw_device v ["-quiet"]
  timeSpentMs <- calcTimeSpentMs
  done <- execCmd v "get_property" ["INPUT_VALUE", getProbeTestDoneTcl]
  success <- execCmd v "get_property" ["INPUT_VALUE", getProbeTestSuccessTcl]
  case (done, success, timeSpentMs >= testTimeoutMs) of
    ("1", "1", _) -> do
      pure ExitSuccess
    ("1", _, _) -> do
      putStrLn $ "HITL test case failure for hardware target " <> prettyShow hwT
      pure (ExitFailure 2)
    (_, _, True) -> do
      putStrLn $
        "HITL test case timeout (≥"
          <> show testTimeoutMs
          <> "ms) for hardware target "
          <> prettyShow hwT
      pure (ExitFailure 3)
    _ -> do
      threadDelay 1000 -- In μs
      pollTestDone startTime testTimeoutMs v hwT
 where
  calcTimeSpentMs = (`div` 1000000) . toNanoSecs . diffTimeSpec startTime <$> getTime Monotonic

runHitlTest ::
  -- | The HITL test group to execute
  HitlTestGroup ->
  -- | Hardware server URL
  String ->
  -- | Path to the generated probes file
  FilePath ->
  -- | Filepath the the ILA data dump directory
  FilePath ->
  IO ExitCode
runHitlTest test@HitlTestGroup{topEntity, testCases, mDriverProc} url probesFilePath ilaDataDir = do
  putStrLn $
    "Starting HITL test for FPGA design '"
      <> show topEntity
      <> "' with "
      <> show (length testCases)
      <> " test cases..."
  result <- try @TclException $ with $ \v -> do
    let testCaseNames = name <$> testCases
    when (anySame testCaseNames) $
      error $
        "HITL test case names must be unique within their test. Offenders: "
          <> show (testCaseNames \\ nubOrd testCaseNames)
    execCmd_ v "set_msg_config" ["-severity {CRITICAL WARNING}", "-new_severity ERROR"]
    execCmd_ v "open_hw_manager" []
    execCmd_ v "connect_hw_server" ["-url " <> url]
    refToHwTMap <- resolveHwTRefs v (hwTargetRefsFromHitlTestGroup test)

    testResults <- forM (zip [1 :: Int ..] testCases) $ \(nr, HitlTestCase{..}) -> do
      putStrLn $
        "Starting HITL test case "
          <> show nr
          <> " out of "
          <> show (length testCases)
          <> " named '"
          <> name
          <> "'..."
      let requestedIds = map idFromHwTRef (Map.keys parameters)
      when (anySame requestedIds) $
        error $
          "Multiple references to the same hardware target: "
            <> show (requestedIds \\ nubOrd requestedIds)
      -- Resolve the test case definition by replacing the references to
      -- hardware targets with the actual hardware targets and device info.
      let
        resolvedTestCase =
          HitlTestCase
            { parameters = mapKeys (\k -> (lookupHwT k, lookupDeviceInfo k)) parameters
            , ..
            }
        lookupHwT key = fromJust $ Map.lookup key refToHwTMap
        lookupDeviceInfo key = deviceInfoFromHwTRef key

      exitCode <-
        runHitlTestCase v resolvedTestCase mDriverProc probesFilePath ilaDataDir
      pure (name, exitCode)

    let failedTestCaseNames = fst <$> filter ((/= ExitSuccess) . snd) testResults
    if null failedTestCaseNames
      then do
        putStrLn $ "All " <> show (length testCases) <> " HITL test cases passed."
      else do
        putStrLn $
          show (length failedTestCaseNames)
            <> " out of "
            <> show (length testCases)
            <> " HITL test cases failed or timed out, namely:"
        mapM_ (putStrLn . ('\t' :)) failedTestCaseNames
    pure $ maximum $ map snd testResults

  case result of
    Left e@TclException{retCode} -> do
      print e
      pure $ ExitFailure (fromMaybe 1 (readMaybe @Int retCode))
    Right exitCode -> pure exitCode

-- | Runs one test case of a HITL test group
runHitlTestCase ::
  forall a b.
  -- | Handle to a Vivado object that is to execute the Tcl
  VivadoHandle ->
  -- | The HITL test case to run
  HitlTestCase (HwTarget, DeviceInfo) a b ->
  -- | Driver function
  Maybe (String -> [(HwTarget, DeviceInfo)] -> VivadoM ExitCode) ->
  -- | Path to the generated probes file
  FilePath ->
  -- | Filepath the the ILA data dump directory
  FilePath ->
  IO ExitCode
runHitlTestCase v testCase@HitlTestCase{name, parameters} driverFunc probesFilePath ilaDataDir = do
  if null parameters
    then do
      putStrLn
        "WARNING: The HITL test case does not reference any hardware targets. Exiting."
      pure ExitSuccess
    else do
      openHwTarget v (fst $ head (keys parameters))
      verifyHwIlas v
      -- XXX: We should not rely on start probe assertion order.
      --      See https://github.com/bittide/bittide-hardware/issues/638.
      testData <- forM (sortOn (prettyShow . fst . fst) (toAscList parameters)) $ \((hwT, deviceInfo), param) -> do
        openHwTarget v hwT
        execCmd_ v "set_property" ["PROBES.FILE", embrace probesFilePath, "[current_hw_device]"]
        refresh_hw_device v []
        let paramBitSize = natToNatural @(BitSize a)
        verifyHitlVio v paramBitSize

        execCmd_ v "set_property" ["OUTPUT_VALUE", "0", getProbeTestStartTcl]
        commit_hw_vio v ["[get_hw_vios]"]
        refresh_hw_vio v ["[get_hw_vios]"]
        done <- execCmd v "get_property" ["INPUT_VALUE", "$probe_test_done"]
        when (done /= "0") $
          error $
            "Hardware target '"
              <> prettyShow hwT
              <> "' asserted its HITL VIO probe done before the test was started."
        unless (paramBitSize == 0) $ do
          hexWidth <- execCmd v "expr" [embrace ("(3 + " <> show paramBitSize <> ")/4")]
          vioValue <-
            execCmd
              v
              "format"
              ["%0" <> hexWidth <> "llX " <> show (BitVector.unsafeToNatural (pack param))]
          putStrLn $ "Setting probe_test_data to " <> vioValue <> "..."
          execCmd_ v "set_property" ["OUTPUT_VALUE", vioValue, getProbeTestDataTcl]

        -- Activate the trigger for each ILA.
        putStrLn "Verifying ILAs..."
        ilas <- get_hw_ilas v []
        unless (null ilas) $
          putStrLn "Configuring and arming ILAs..."

        forM_ ilas $ \ila -> do
          _ <- current_hw_ila v [show ila]

          -- Set trigger probe (active high boolean)
          -- TODO get probe from Tcl dictionary?
          let triggerProbe = "[get_hw_probes -of_objects [current_hw_ila] */trigger*]"
          execCmd_ v "set_property" ["trigger_compare_value", "eq1'b1", triggerProbe]

          -- Enable capture control and set capture probe (active high boolean)
          execCmd_ v "set_property" ["control.capture_mode", "BASIC", "[current_hw_ila]"]
          let captureProbe = "[get_hw_probes -of_objects [current_hw_ila] */capture*]"
          execCmd_ v "set_property" ["capture_compare_value", "eq1'b1", captureProbe]

          -- Set the trigger position
          execCmd_ v "set_property" ["control.trigger_position", "0", "[current_hw_ila]"]

          run_hw_ila v ["[current_hw_ila]"]

        -- Deassert HitlVio start probe
        -- XXX: We should not rely on start probe values to be asserted after a
        --      test ends. See https://github.com/bittide/bittide-hardware/issues/639.
        execCmd_ v "set_property" ["OUTPUT_VALUE", "0", getProbeTestStartTcl]
        commit_hw_vio v ["[get_hw_vios]"]

        return (hwT, deviceInfo)

      -- Assert HitlVio start probe
      -- execCmd_ v "set_property" ["OUTPUT_VALUE", "1", getProbeTestStartTcl]
      -- commit_hw_vio v ["[get_hw_vios]"]
      -- putStrLn $ "Started test case for hardware target " <> prettyShow hwT <> "."

      -- pure testRunData

      testCaseExitCode <- case driverFunc of
        Just fn -> do
          putStrLn $ "Running custom driver function for test " <> name
          let
            catchException :: SomeException -> IO ExitCode
            catchException e = do
              putStrLn $ "Caught exception while running driver function: " <> displayException e
              putStrLn "Carrying on to save ILA data."
              return $ ExitFailure 3
          catch (runReaderT (fn name testData) v) catchException
        Nothing -> do
          putStrLn $ "Running default driver function for test " <> name

          forM_ testData $ \(hwT, _deviceInfo) -> do
            -- Assert HitlVio start probe
            openHwTarget v hwT
            execCmd_ v "set_property" ["PROBES.FILE", embrace probesFilePath, "[current_hw_device]"]
            refresh_hw_device v []

            execCmd_ v "set_property" ["OUTPUT_VALUE", "1", getProbeTestStartTcl]
            commit_hw_vio v ["[get_hw_vios]"]
            putStrLn $ "Started test case for hardware target " <> prettyShow hwT <> "."

          putStrLn $ "Waiting for test case '" <> name <> "' to end..."
          waitTestCaseEnd v testCase probesFilePath

      putStrLn "Saving captured ILA data (if relevant)..."
      forM_ (keys parameters) $ \(hwT, _) -> do
        openHwTarget v hwT
        execCmd_ v "set_property" ["PROBES.FILE", embrace probesFilePath, "[current_hw_device]"]
        refresh_hw_device v ["-quiet"]
        ilas <- get_hw_ilas v []
        let dir = ilaDataDir </> name </> prettyShow hwT
        unless (null ilas) $ do
          putStrLn $
            "Saving captured ILA data to: " <> dir
          createDirectoryIfMissing True dir
        usedShortNamesVar <- newMVar mempty
        forM_ ilas $ \ila -> do
          _ <- current_hw_ila v [show ila]
          ilaShortName0 <- getCurrentIlaShortName v
          ilaShortName <- mkUniqShortName usedShortNamesVar ilaShortName0 (fromHwIla ila)
          execCmd_ v "current_hw_ila_data" ["[upload_hw_ila_data [current_hw_ila]]"]
          -- Legacy CSV excludes radix information
          execCmd_
            v
            "write_hw_ila_data"
            ["-force", "-legacy_csv_file " <> embrace (dir </> ilaShortName)]
          execCmd_ v "write_hw_ila_data" ["-force", "-vcd_file " <> embrace (dir </> ilaShortName)]

      -- deassert all START signals
      forM_ (sortOn (prettyShow . fst . fst) (toAscList parameters)) $ \((hwT, _), _param) -> do
        openHwTarget v hwT
        execCmd_ v "set_property" ["PROBES.FILE", embrace probesFilePath, "[current_hw_device]"]
        refresh_hw_device v []

        execCmd_ v "set_property" ["OUTPUT_VALUE", "0", getProbeTestStartTcl]
        commit_hw_vio v ["[get_hw_vios]"]

      pure testCaseExitCode

mkUniqShortName :: MVar (Set String) -> String -> String -> IO String
mkUniqShortName refUsedNames shortName name =
  modifyMVar refUsedNames $ \usedNames -> do
    let
      nm0 = shortName
      nm1 = nm0 <> "_" <> name
      nm
        | Set.notMember nm0 usedNames = nm0
        | Set.notMember nm1 usedNames = nm1
        | otherwise =
            error [i|Failed to create unique shortname for #{name}, original shortname #{shortName}|]
    return (Set.insert nm usedNames, nm)
