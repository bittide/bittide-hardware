-- SPDX-FileCopyrightText: 2022-2024 Google LLC
--
-- SPDX-License-Identifier: Apache-2.0

{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE RecordWildCards #-}

-- | Generate a TCL script to simulate generated VHDL
--
-- Run with @vivado -mode batch -source ...@
--
module Clash.Shake.Vivado
  ( LocatedManifest(..)
  , BoardPart(..)
  , decodeLocatedManifest
  , mkSynthesisTcl
  , mkPlaceAndRouteTcl
  , mkBitstreamTcl
  , mkProbesGenTcl
  , mkBoardProgramTcl
  , mkHardwareTestTcl
  , meetsTiming
  , meetsDrc
  ) where

import Prelude

import Development.Shake
import Development.Shake.Extra (decodeFile)

import Control.Monad.Extra (andM, orM)
import Clash.DataFiles (tclConnector)
import Clash.Driver.Manifest
import Data.List (isInfixOf, intercalate)
import Data.String.Interpolate (__i)
import System.FilePath ((</>), dropFileName)

import Clash.Shake.Extra (hexDigestFile)
import Clash.Shake.Flags (HardwareTargets(..))

import Paths_bittide_shake

-- | Satisfied if all actions result in 'False'
noneM :: Monad m => [m Bool] -> m Bool
noneM = fmap not . orM

-- | Whether a string occurs in a file
inFile :: String -> FilePath -> IO Bool
inFile msg path = do
  content <- readFile path
  pure $ (msg `isInfixOf` content)

-- | Read a timing summary or DRC report and determine whether it passed DRC
-- checks.
meetsDrc :: FilePath -> IO Bool
meetsDrc path = noneM
  [ inFile "No report available as report_methodology has not been run prior." path
  , inFile "Critical Warning" path
  ]

-- | Read a timing summary and determine whether it met timing.
meetsTiming :: FilePath -> IO Bool
meetsTiming path = andM
  [ meetsDrc path -- for safety; users should use meetDrc for useful error reporting
  , fmap not $ inFile "Timing constraints are not met" path
  ]

-- TODO: Upstream
data LocatedManifest = LocatedManifest
  { -- | Path pointing to the manifest file itself
    lmPath :: FilePath

    -- | Manifest file corresponding to the one at 'lmPath'
  , lmManifest :: Manifest
  }

decodeLocatedManifest :: FilePath -> Action LocatedManifest
decodeLocatedManifest path = LocatedManifest path <$> decodeFile path

-- | Vivado board part or part. If a board part is set, Vivado will infer the
-- part on that board.
data BoardPart
  = Board String
  | Part String

-- | Generate Tcl that sets the board part or part for the current project
mkBoardPartTcl :: BoardPart -> String
mkBoardPartTcl boardPart = case boardPart of
  (Board name) -> "set_property board_part " <> name <> " [current_project]"
  (Part name) -> "set_property part " <> name <> " [current_project]"

-- | Generates TCL that generates and reads Xilinx IP and reads constraints and
-- HDL files generated by Clash. The caller is responsible for starting synthesis
-- or simulation.
--
mkBaseTcl ::
  -- | Where to create ip directory.
  FilePath ->
  -- | Top entity directory
  LocatedManifest ->
  -- | Board part or part to synthesize for
  BoardPart ->
  -- | TCL script
  Action String
mkBaseTcl outputDir LocatedManifest{lmPath} boardPart = do
  connector <- liftIO tclConnector
  connectorDigest <- hexDigestFile connector
  lmPathDigest <- hexDigestFile lmPath
  let
    topEntityDir = dropFileName lmPath
    boardPartTcl = mkBoardPartTcl boardPart

  pure [__i|
    \# #{lmPath}: #{lmPathDigest}
    \# #{connector}: #{connectorDigest}
    set_msg_config -severity {CRITICAL WARNING} -new_severity ERROR
    source -notrace {#{connector}}
    file delete -force {#{outputDir </> "ip"}}
    file mkdir {#{outputDir </> "ip"}}
    clash::readMetadata {#{topEntityDir}}

    set hasIp [expr [llength [clash::GetAllTclIfaces {purposes createIp}]] > 0]

    if {${hasIp}} {
      create_project -in_memory
      #{boardPartTcl}
      set ips [clash::createIp -dir {#{outputDir </> "ip"}}]
      set ipFiles [get_property IP_FILE [get_ips $ips]]
      close_project
    }

    clash::readHdl
    #{boardPartTcl}

    if {${hasIp}} {
      read_ip $ipFiles
      set_property GENERATE_SYNTH_CHECKPOINT false [get_files $ipFiles]
      generate_target {synthesis simulation} [get_ips $ips]
    }

    clash::readXdc {early normal late}
    set_property TOP $clash::topEntity [current_fileset]
  |]

mkSynthesisTcl ::
  -- | Directory to write logs and checkpoints to
  FilePath ->
  -- | Out of context?
  Bool ->
  -- | Board part or part to synthesize for. E.g., 'xcku040-ffva1156-2-e'.
  BoardPart ->
  -- | List of filepaths to XDC files
  [FilePath] ->
  -- | Manifests of which the first is the top-level to synthesize
  LocatedManifest ->
  -- | Rendered TCL
  Action String
mkSynthesisTcl outputDir outOfContext boardPart constraints manifest@LocatedManifest{lmManifest} = do
  baseTcl <- mkBaseTcl outputDir manifest boardPart
  constraintDigests <- unlines <$> mapM constraintDigest constraints
  pure $ baseTcl <> "\n" <> [__i|
    #{constraintDigests}
    set_msg_config -severity {CRITICAL WARNING} -new_severity ERROR

    set_param synth.elaboration.rodinMoreOptions "rt::set_parameter var_size_limit 4194304"
    #{constraintsString}
    file mkdir {#{outputDir </> "reports"}}
    file mkdir {#{outputDir </> "checkpoints"}}

    \# Synthesis
    synth_design -name #{name} -mode #{outOfContextStr}
    report_methodology -file {#{outputDir </> "reports" </> "post_synth_methodology.rpt"}}
    report_timing_summary -file {#{outputDir </> "reports" </> "post_synth_timing_summary.rpt"}}
    report_utilization -file {#{outputDir </> "reports" </> "post_synth_util.rpt"}}
    write_checkpoint -force {#{outputDir </> "checkpoints" </> "post_synth.dcp"}}

    \# Netlist
    file mkdir {#{outputDir </> "netlist"}}
    write_verilog -force {#{outputDir </> "netlist" </> "netlist.v"}}
    write_xdc -no_fixed_only -force {#{outputDir </> "netlist" </> "netlist.xdc"}}
  |]
 where
  name = topComponent lmManifest
  outOfContextStr
    | outOfContext = "out_of_context" :: String
    | otherwise    = "default"
  constraintReader constr = "read_xdc -unmanaged {" <> constr <> "}\n"
  constraintsString = concatMap constraintReader constraints

  constraintDigest path = do
    pathDigest <- hexDigestFile path
    pure [__i|\# #{path}: #{pathDigest}|]

mkPlaceAndRouteTcl :: FilePath -> String
mkPlaceAndRouteTcl outputDir = [__i|
    set_msg_config -severity {CRITICAL WARNING} -new_severity ERROR

    \# Pick up where synthesis left off
    open_checkpoint {#{outputDir </> "checkpoints" </> "post_synth.dcp"}}

    \# Run optimization & placement
    opt_design
    place_design
    phys_opt_design
    write_checkpoint -force {#{outputDir </> "checkpoints" </> "post_place.dcp"}}

    \# Routing
    route_design
    write_checkpoint -force {#{outputDir </> "checkpoints" </> "post_route.dcp"}}
    report_methodology -file {#{outputDir </> "reports" </> "post_route_methodology.rpt"}}
    report_timing_summary -file {#{outputDir </> "reports" </> "post_route_timing_summary.rpt"}}
    report_timing -sort_by group -max_paths 100 -path_type summary -file {#{outputDir </> "reports" </> "post_route_timing.rpt"}}

    report_clock_utilization -file {#{outputDir </> "reports" </> "post_route_clock_util.rpt"}}
    report_utilization       -file {#{outputDir </> "reports" </> "post_route_util.rpt"}}
    report_power             -file {#{outputDir </> "reports" </> "post_route_power.rpt"}}
    report_drc               -file {#{outputDir </> "reports" </> "post_route_drc.rpt"}}

    \# Generate netlist and constraints
    file mkdir {#{outputDir </> "netlist"}}
    write_verilog -force {#{outputDir </> "netlist" </> "netlist.v"}}
    write_xdc -no_fixed_only -force {#{outputDir </> "netlist" </> "netlist.xdc"}}
|]

mkBitstreamTcl :: FilePath -> String
mkBitstreamTcl outputDir = [__i|
    set_msg_config -severity {CRITICAL WARNING} -new_severity ERROR

    \# Pick up where netlist left off
    open_checkpoint {#{outputDir </> "checkpoints" </> "post_route.dcp"}}

    \# Generate bitstream
    set_property BITSTREAM.GENERAL.COMPRESS TRUE [current_design]
    write_bitstream -force {#{outputDir </> "bitstream.bit"}}
|]

mkProbesGenTcl :: FilePath -> String
mkProbesGenTcl outputDir = [__i|
    set_msg_config -severity {CRITICAL WARNING} -new_severity ERROR

    \# Pick up where netlist left off
    open_checkpoint {#{outputDir </> "checkpoints" </> "post_route.dcp"}}

    \# Generate probes file
    write_debug_probes -force {#{outputDir </> "probes.ltx"}}
|]

-- | Convert HardwareTargets to a Tcl list of target FPGAs. To be used in
-- combination with `fpga_ids` in `HardwareTest.tcl`
toTclTarget :: HardwareTargets -> String
toTclTarget hwTargets =
  let
    listToTcl :: [Int] -> String
    listToTcl xs = "[list " <> (intercalate " " $ map show xs) <> "]"
  in case hwTargets of
    OneAny -> listToTcl []
    Specific xs -> listToTcl $ map (`mod` 8) xs
    All -> listToTcl [0..7]

mkBoardProgramTcl ::
  -- | Directory where the bitstream file are located
  FilePath ->
  -- | Hardware targets to program, see `Flags.hs`
  HardwareTargets ->
  -- | Hardware server URL
  String ->
  -- | Flag indicating if the target has a probes file. If true, the probes file
  -- is programmed alongside the bitstream.
  Bool ->
  -- | Rendered Tcl
  IO String
mkBoardProgramTcl outputDir hwTargets url hasProbesFile = do
  hardwareTestTclPath <- getDataFileName ("data" </> "tcl" </> "HardwareTest.tcl")
  let
    probesTcl :: String
    probesTcl
      | hasProbesFile = [__i|set probes_file {#{outputDir </> "probes.ltx"}}|]
      | otherwise = "set probes_file {}"

  pure [__i|
    source {#{hardwareTestTclPath}} -notrace
    global fpga_ids

    set_msg_config -severity {CRITICAL WARNING} -new_severity ERROR

    set fpga_nrs #{toTclTarget hwTargets}
    set program_file {#{outputDir </> "bitstream.bit"}}
    set url {#{url}}
    #{probesTcl}

    open_hw_manager
    connect_hw_server -url $url
    set target_dict [get_target_dict ${url} ${fpga_nrs}]
    has_expected_targets ${url} ${target_dict}

    dict for {target_nr target_id} $target_dict {
      set target_name [get_part_name $url $target_id]
      set device [load_target_device $target_name]
      program_fpga ${program_file} ${probes_file}
    }
  |]


mkHardwareTestTcl ::
  -- | Path to test configuration
  FilePath ->
  -- | Directory where the probes file is located
  FilePath ->
  -- | Hardware targets to program, see `Flags.hs`
  HardwareTargets ->
  -- | Hardware server URL
  String ->
  -- | Filepath the the ILA data dump directory
  FilePath ->
  -- | Rendered Tcl
  IO String
mkHardwareTestTcl testConfigPath outputDir hwTargets url ilaDataPath = do
  hardwareTestTclPath <- getDataFileName ("data" </> "tcl" </> "HardwareTest.tcl")
  pure [__i|
    source {#{hardwareTestTclPath}} -notrace
    set_msg_config -severity {CRITICAL WARNING} -new_severity ERROR

    set fpga_nrs #{toTclTarget hwTargets}
    set probes_file {#{outputDir </> "probes.ltx"}}
    set test_config_file {#{testConfigPath}}
    set url {#{url}}

    open_hw_manager
    connect_hw_server -url $url
    set target_dict [get_target_dict ${url} ${fpga_nrs}]
    has_expected_targets ${url} ${target_dict}

    run_test_group $probes_file $test_config_file $target_dict $url {#{ilaDataPath}}
  |]
