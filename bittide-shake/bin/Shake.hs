-- SPDX-FileCopyrightText: 2022-2023 Google LLC
--
-- SPDX-License-Identifier: Apache-2.0

{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE RecordWildCards #-}

module Main where

import Prelude

import Control.Applicative (liftA2)
import Control.Monad.Extra (ifM, unlessM, when)
import Data.Char(isSpace)
import Data.Foldable (for_)
import Data.List (dropWhileEnd)
import Development.Shake
import GHC.Stack (HasCallStack)
import System.Console.ANSI (setSGR)
import System.Directory (getCurrentDirectory, setCurrentDirectory)
import System.FilePath (isDrive, (</>), takeDirectory)
import System.Process (readProcess)

import Paths_bittide_shake

import Clash.Shake.Flags
import Clash.Shake.Vivado
import Clash.Shake.Extra

import qualified Clash.Util.Interpolate as I
import qualified System.Directory as Directory

{- [Note: invalidating HDL cache]

Ideally, Shake would be perfectly aware of all source files needed to build RTL
generated by Clash. It would - among other things - read 'bittide-instances.cabal',
discover dependencies, need _their_ cabal files, need the Haskell files they
point to, etc. Any change in these files would then restart the recovery process,
and instruct Clash to rebuild RTL.

Alas, we use Cabal as a build tool hence Shake is unaware of the exact files
needed to trigger a Clash build. As a workaround, we pessimistically assume that
_any_ file in the repository (for details see 'getWatchFiles') can trigger a
rebuild. Hence, the Clash build job will list:

    needWatchFiles

Unfortunately, this isn't quite enough still to trigger a rebuild when adding a
new Haskell module. Even though Shake will discover an associated Cabal file to
have changed†, but will not watch the new module added to that Cabal file. In
order to work around this, 'needWatchFiles' is used twice:

    needWatchFiles  -- will trigger on .cabal change
    needWatchFiles  -- will discover new file

In the future we might be more precise in our source discovery process.

† Note that Cabal itself will misbehave when a file is not explicitly mentioned
  in a cabal file, but is imported in a listed one. We therefore will not try to
  handle this case in Shake either.
-}

-- | Get all files whose changes will trigger an HDL rebuild. Because we lack a
-- reliable way to determine which files should trigger a rebuild, this function
-- returns a (very) pessimistic list: all files in the project's directory,
-- except files ignored by git and files matching patterns in 'ignorePatterns'.
getWatchFiles :: IO [String]
getWatchFiles = do
  getWatchFilesPy <- getDataFileName ("data" </> "scripts" </> "get_watch_files.py")
  lines <$> readProcess getWatchFilesPy ignorePatterns ""

-- | Call 'need' on output of 'getWatchFiles'
needWatchFiles :: Action ()
needWatchFiles = need =<< liftIO getWatchFiles

-- | File patterns of file we do _not_ want to make trigger a rebuild of HDL
-- files. Also see 'getWatchFiles'.
ignorePatterns :: [String]
ignorePatterns =
  [ "*.md"
  , ".github"
  , ".reuse"
  , ".vscode"

  -- Used for synthesis, but not for generating Clash output:
  , "bittide-instances/data/constraints/*.xdc"
  , "bittide-instances/data/tcl/*.tcl"
  ]

-- | Given Cabal project root, determine build directory
buildDir :: FilePath
buildDir = "_build"

-- | Given Cabal project root, determine Clash HDL output directory
clashBuildDir :: FilePath
clashBuildDir = buildDir </> "clash"

-- | Given Cabal project root, determine directory for Vivado input + output files
vivadoBuildDir :: FilePath
vivadoBuildDir = buildDir </> "vivado"

getConstraintFilePath :: String -> IO FilePath
getConstraintFilePath target = do
  out <- readProcess "cabal"
    [ "run"
    , "-v0"
    , "get-data-file-name"
    , "data/constraints" </> entityName target <> ".xdc"
    ] ""
  pure $ dropWhileEnd isSpace $ dropWhile isSpace out


-- | Searches for a file called @cabal.project@ It will look for it in the
-- current working directory. If it can't find it there, it will traverse up
-- until it finds the file.
--
-- The returned path points to the directory containing @cabal.project@. Errors
-- if it could not find @cabal.project@ anywhere.
--
findProjectRoot :: HasCallStack => IO FilePath
findProjectRoot = goUp =<< getCurrentDirectory
 where
  goUp :: FilePath -> IO FilePath
  goUp path
    | isDrive path = error "Could not find 'cabal.project'"
    | otherwise =
        ifM
          (Directory.doesFileExist (path </> projectFilename))
          (return path)
          (goUp (takeDirectory path))

  projectFilename = "cabal.project"

data Target = Target
  { -- | TemplateHaskell reference to top entity to synthesize
    targetName :: TargetName

    -- | Whether target has an associated XDC file in 'data/constraints'. An XDC
    -- file implies that a bitstream can be generated.
  , targetHasXdc :: Bool

    -- | Whether target has one or more VIOs
  , targetHasVio :: Bool

    -- | Whether target has a VIO probe that can be used to run hardware-in-the-
    -- loop tests. Note that this flag, 'targetHasTest', implies 'targetHasVio'.
  , targetHasTest :: Bool
  }

defTarget :: TargetName -> Target
defTarget name = Target
  { targetName = name
  , targetHasXdc = False
  , targetHasVio = False
  , targetHasTest = False
  }

testTarget :: TargetName -> Target
testTarget name = Target
  { targetName = name
  , targetHasXdc = True
  , targetHasVio = True
  , targetHasTest = True
  }

enforceValidTarget :: Target -> Target
enforceValidTarget target@Target{..}
  | targetHasTest && not targetHasVio =
      error $ show targetName <> " should have set 'targetHasVio', because " <>
                                 "'targetHasTest' was asserted."
  | otherwise = target


-- | All synthesizable targets
targets :: [Target]
targets = map enforceValidTarget
  [ defTarget "Bittide.Instances.Calendar.switchCalendar1k"
  , defTarget "Bittide.Instances.Calendar.switchCalendar1kReducedPins"
  , defTarget "Bittide.Instances.ClockControl.callisto3"
  , defTarget "Bittide.Instances.Counter.counterReducedPins"
  , defTarget "Bittide.Instances.ElasticBuffer.elasticBuffer5"
  , (defTarget "Bittide.Instances.MVPs.clockControlDemo0") {targetHasXdc = True}
  , (defTarget "Bittide.Instances.MVPs.clockControlDemo1") {targetHasXdc = True}
  , defTarget "Bittide.Instances.ScatterGather.gatherUnit1K"
  , defTarget "Bittide.Instances.ScatterGather.gatherUnit1KReducedPins"
  , defTarget "Bittide.Instances.ScatterGather.scatterUnit1K"
  , defTarget "Bittide.Instances.ScatterGather.scatterUnit1KReducedPins"
  , defTarget "Bittide.Instances.Si539xSpi.callistoSpi"
  , defTarget "Bittide.Instances.Si539xSpi.si5391Spi"
  , defTarget "Bittide.Instances.StabilityChecker.stabilityChecker_3_1M"
  , defTarget "Bittide.Instances.Synchronizer.safeDffSynchronizer"

  , testTarget "Bittide.Instances.BoardTest.extendedHardwareInTheLoopTest"
  , testTarget "Bittide.Instances.BoardTest.simpleHardwareInTheLoopTest"
  , testTarget "Bittide.Instances.Tests.FincFdec.fincFdecTests"
  , testTarget "Bittide.Instances.Tests.VexRiscv.vexRiscvTest"
  ]

shakeOpts :: ShakeOptions
shakeOpts = shakeOptions
  { shakeFiles = buildDir
  , shakeChange = ChangeDigest
  , shakeVersion = "6"
  }

-- | Run Vivado on given TCL script
vivadoFromTcl :: FilePath -> Action ()
vivadoFromTcl tclPath =
  command_
    [AddEnv "XILINX_LOCAL_USER_DATA" "no"] -- Prevents multiprocessing issues
    "vivado"
    ["-mode", "batch", "-source", tclPath]

-- | Constructs a 'BoardPart' based on environment variables @SYNTHESIS_BOARD@
-- or @SYNTHESIS_PART@. Errors if both are set, returns a default (free) part
-- if neither is set.
getBoardPart :: Action BoardPart
getBoardPart = do
  boardName <- getEnv "SYNTHESIS_BOARD"
  partName <- getEnv "SYNTHESIS_PART"
  case (boardName, partName) of
    (Just b,  Nothing) -> pure $ Board b
    (Nothing, Just p)  -> pure $ Part p
    (Nothing, Nothing) -> pure $ Part "xcku035-ffva1156-2-e"
    (Just _b,  Just _p)  ->
      error "Both 'SYNTHESIS_BOARD' and 'SYNTHESIS_PART' are set, unset either and retry"

-- | Inspect DRC and timing report. Throw an error if suspicious strings were
-- found.
meetsDrcOrError :: FilePath -> FilePath -> FilePath -> IO ()
meetsDrcOrError methodologyPath summaryPath checkpointPath =
  unlessM
    (liftA2 (&&) (meetsTiming methodologyPath) (meetsTiming summaryPath))
    (error [I.i|
      Design did not meet design rule checks (DRC). Check out the timing summary at:

        #{summaryPath}

      Check out the methodology report at:

        #{methodologyPath}

      You can investigate interactively by opening the latest checkpoint with Vivado:

        vivado #{checkpointPath}

    |])

-- | Defines a Shake build executable for calling Vivado. Like Make, in Shake
-- you define rules that explain how to build a certain file. For example:
--
--     manifestPath %> ...
--
-- means: to build @manifestPath@ I need to do dot-dot-dot. See the README for
-- an overview of which commands are user-passable (or simply scroll down).
--
-- For a fundamental introduction into Shake, read the (lightweight!) paper
-- introducing it:
--
--   https://ndmitchell.com/downloads/paper-shake_before_building-10_sep_2012.pdf.
--
-- Or, see https://shakebuild.com/.
--
main :: IO ()
main = do
  setCurrentDirectory =<< findProjectRoot

  shakeArgsWith shakeOpts customFlags $ \flags shakeTargets -> pure $ Just $ do

    let
      hwTargets = getHardwareTargetsFlag flags

      rules = do
        -- 'all' builds all targets defined below
        phony "all" $ do
          for_ targets $ \Target{..} -> do
            need [entityName targetName <> ":synth"]

        -- For each target, generate a user callable command (PHONY). Run with
        -- '--help' to list them.
        for_ targets $ \Target{..}-> do
          let
            -- TODO: Dehardcode these paths. They're currently hardcoded in both the
            --       TCL and here, which smells.
            manifestPath = getManifestLocation clashBuildDir targetName
            synthesisDir = vivadoBuildDir </> targetName
            checkpointsDir = synthesisDir </> "checkpoints"
            netlistDir = synthesisDir </> "netlist"
            reportDir = synthesisDir </> "reports"

            runSynthTclPath        = synthesisDir </> "run_synth.tcl"
            runPlaceTclPath        = synthesisDir </> "run_place.tcl"
            runRouteTclPath        = synthesisDir </> "run_route.tcl"
            runNetlistTclPath      = synthesisDir </> "run_netlist.tcl"
            runBitstreamTclPath    = synthesisDir </> "run_bitstream.tcl"
            runProbesGenTclPath    = synthesisDir </> "run_probes_gen.tcl"
            runBoardProgramTclPath = synthesisDir </> "run_board_program.tcl"
            runHardwareTestTclPath = synthesisDir </> "run_hardware_test.tcl"

            postSynthCheckpointPath     = checkpointsDir </> "post_synth.dcp"
            postPlaceCheckpointPath     = checkpointsDir </> "post_place.dcp"
            postRouteCheckpointPath     = checkpointsDir </> "post_route.dcp"
            postNetlistCheckpointPath   = checkpointsDir </> "post_netlist.dcp"

            netlistPaths =
              [ netlistDir </> "netlist.v"
              , netlistDir </> "netlist.xdc"
              ]
            bitstreamPath = synthesisDir </> "bitstream.bit"
            probesPath = synthesisDir </> "probes.ltx"

            postRouteMethodologyPath = reportDir </> "post_route_methodology.rpt"
            postRouteTimingSummaryPath = reportDir </> "post_route_timing_summary.rpt"
            postRouteTimingPath = reportDir </> "post_route_timing.rpt"

            synthReportsPaths = [reportDir </> "post_synth_timing_summary.rpt"]
            placeReportPaths = [reportDir </> "post_place_timing_summary.rpt"]
            routeReportsPaths =
              [ reportDir </> "post_route_clock_util.rpt"
              , reportDir </> "post_route_drc.rpt"
              , reportDir </> "post_route_methodology.rpt"
              , reportDir </> "post_route_power.rpt"
              , reportDir </> "post_route_timing_summary.rpt"
              , reportDir </> "post_route_timing.rpt"
              , reportDir </> "post_route_util.rpt"
              ]

          withoutTargets $ do
            manifestPath %> \path -> do
              --- XXX: See [Note: invalidating HDL cache]
              needWatchFiles
              needWatchFiles

              let
                (buildTool, buildToolArgs) =
                  defaultClashCmd clashBuildDir targetName
              command_ [] buildTool buildToolArgs

              -- Clash messes up ANSI escape codes, leaving the rest of the terminal
              -- printed in bold text. Reset manually:
              liftIO (setSGR [])

              produces [path]

            -- Synthesis
            runSynthTclPath %> \path -> do

              constraints <-
                if targetHasXdc then do
                  constraintFilePath <- liftIO (getConstraintFilePath targetName)
                  need [constraintFilePath]
                  pure [constraintFilePath]
                else
                  pure []

              synthesisPart <- getBoardPart
              locatedManifest <- decodeLocatedManifest manifestPath

              tcl <-
                mkSynthesisTcl
                  synthesisDir            -- Output directory for Vivado
                  False                   -- Out of context run
                  synthesisPart           -- Part we're synthesizing for
                  constraints             -- List of filenames with constraints
                  locatedManifest

              writeFileChanged path tcl

            (postSynthCheckpointPath : synthReportsPaths) |%> \_ -> do
              -- XXX: Will not re-run if _dependencies_ mentioned in 'manifestPath'
              --      change. This is only relevant in designs with multiple
              --      binders with 'Synthesize' pragmas, which we currently do
              --      not have. Ideally we would parse the manifest file and
              --      also depend on the dependencies' manifest files, etc.
              need [runSynthTclPath, manifestPath]
              vivadoFromTcl runSynthTclPath

            -- Placement
            runPlaceTclPath %> \path -> do
              writeFileChanged path (mkPlaceTcl synthesisDir)

            (postPlaceCheckpointPath : placeReportPaths) |%> \_ -> do
              need [runPlaceTclPath, postSynthCheckpointPath]
              vivadoFromTcl runPlaceTclPath

            -- Routing
            runRouteTclPath %> \path -> do
              writeFileChanged path (mkRouteTcl synthesisDir)

            (postRouteCheckpointPath : routeReportsPaths) |%> \_ -> do
              need [runRouteTclPath, postPlaceCheckpointPath]
              vivadoFromTcl runRouteTclPath

              -- Design should meet design rule checks (DRC).
              liftIO $ unlessM
                ( liftA2
                    (&&)
                    (meetsTiming postRouteMethodologyPath)
                    (meetsTiming postRouteTimingSummaryPath)
                )
                (error [I.i|
                  Design did not meet design rule checks (DRC). Check out the timing summary at:

                    #{postRouteTimingSummaryPath}

                  Check out the methodology report at:

                    #{postRouteMethodologyPath}

                  You can investigate interactively by opening the latest checkpoint with Vivado:

                    vivado #{postRouteCheckpointPath}

                |])

              -- Design should meet timing post routing. Note that this is not a
              -- requirement after synthesis as many of the optimizations only follow
              -- after.
              liftIO $ unlessM
                (meetsTiming postRouteTimingSummaryPath)
                (error [I.i|
                  Design did not meet timing. Check out the timing summary at:

                    #{postRouteTimingSummaryPath}

                  Alternatively, check out the full report:

                    #{postRouteTimingPath}

                  You can investigate interactively by opening the latest checkpoint with Vivado:

                    vivado #{postRouteCheckpointPath}

                |])

            -- Netlist generation
            runNetlistTclPath %> \path -> do
              writeFileChanged path (mkNetlistTcl synthesisDir)

            (postNetlistCheckpointPath : netlistPaths) |%> \_ -> do
              need [runNetlistTclPath, postRouteCheckpointPath]
              vivadoFromTcl runNetlistTclPath

            -- Bitstream generation
            runBitstreamTclPath %> \path -> do
              writeFileChanged path (mkBitstreamTcl synthesisDir)

            bitstreamPath %> \_ -> do
              need [runBitstreamTclPath, postNetlistCheckpointPath]
              vivadoFromTcl runBitstreamTclPath

            -- Probes file generation
            runProbesGenTclPath %> \path -> do
              writeFileChanged path (mkProbesGenTcl synthesisDir)

            probesPath %> \_ -> do
              need [runProbesGenTclPath, bitstreamPath]
              vivadoFromTcl runProbesGenTclPath

            -- Write bitstream to board
            runBoardProgramTclPath %> \path -> do
              alwaysRerun
              url <- getEnvWithDefault "localhost:3121" "HW_SERVER_URL"
              boardProgramTcl <-
                liftIO $ mkBoardProgramTcl synthesisDir hwTargets url targetHasVio
              writeFileChanged path boardProgramTcl

            -- Run hardware test
            runHardwareTestTclPath %> \path -> do
              alwaysRerun
              url <- getEnvWithDefault "localhost:3121" "HW_SERVER_URL"
              hardwareTestTcl <- liftIO $ mkHardwareTestTcl synthesisDir hwTargets url
              writeFileChanged path hardwareTestTcl


          -- User friendly target names
          phony (entityName targetName <> ":hdl") $ do
            need [manifestPath]

          phony (entityName targetName <> ":synth") $ do
            need [postSynthCheckpointPath]

          phony (entityName targetName <> ":place") $ do
            need [postPlaceCheckpointPath]

          phony (entityName targetName <> ":route") $ do
            need [postRouteCheckpointPath]

          phony (entityName targetName <> ":netlist") $ do
            need [postNetlistCheckpointPath]

          when targetHasXdc $ do
            phony (entityName targetName <> ":bitstream") $ do
              when targetHasVio $ need [probesPath]
              need [bitstreamPath]

            phony (entityName targetName <> ":program") $ do
              when targetHasVio $ need [probesPath]
              need [runBoardProgramTclPath, bitstreamPath]
              vivadoFromTcl runBoardProgramTclPath

            when targetHasTest $ do
              phony (entityName targetName <> ":test") $ do
                need
                  [ runBoardProgramTclPath
                  , runHardwareTestTclPath
                  , bitstreamPath
                  , probesPath
                  ]
                vivadoFromTcl runBoardProgramTclPath
                vivadoFromTcl runHardwareTestTclPath

    if null shakeTargets then
      rules
    else
      want shakeTargets >> withoutActions rules
