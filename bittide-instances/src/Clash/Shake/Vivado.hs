-- SPDX-FileCopyrightText: 2022 Google LLC
--
-- SPDX-License-Identifier: Apache-2.0

{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}

-- | Generate a TCL script to simulate generated VHDL
--
-- Run with @vivado -mode batch -source ...@
--
-- Note: This module has been copied almost 1:1 from Clash's testsuite. The authors
--       have agreed to relicense it to Apache-2.0. However, we should figure out
--       a way to expose this code on Hackage.
--
-- Note: Although initialy copied 1:1, this module now has quite a number of
--       modifications; mostly due to the testsuite trying to do IO itself while
--       `bittide-instances` levarages Shake for that. In top of that, clash-testsuite
--       focusses on simulation, while bittide-instances focusses on synthesis -
--       warrenting more changes. We should unify and upstream.
--
module Clash.Shake.Vivado where

import Prelude

import Clash.Driver.Manifest
import Data.List (isSuffixOf)
import Data.List.NonEmpty (NonEmpty ((:|)))
import Data.Maybe (mapMaybe)
import Data.String.Interpolate (__i)
import GHC.IO (unsafePerformIO)
import System.FilePath ((</>), dropFileName)

import Paths_bittide_instances (getDataDir)

import qualified Data.Text as T

-- TODO: Upstream
data LocatedManifest = LocatedManifest
  { -- | Path pointing to the manifest file itself
    lmPath :: FilePath

    -- | Manifest file corresponding to the one at 'lmPath'
  , lmManifest :: Manifest
  }

-- | Directory where all entities are stored. Probably equal to the value of
-- @-fclash-hdldir@ passed to Clash.
projectDirectory :: LocatedManifest -> FilePath
projectDirectory manifest = entityDirectory manifest </> ".."

-- | Directory where all HDL files are located for given entity
entityDirectory :: LocatedManifest -> FilePath
entityDirectory manifest = dropFileName (lmPath manifest)

data SourceType
  = VhdlSource
  | VerilogSource
  | SystemVerilogSource
  | TclSource
  | SdcSource
  | XdcSource
  deriving (Eq, Show)

data HdlSource = HdlSource
  { hdlType :: SourceType
  , hdlLib :: T.Text
  , hdlFile :: FilePath
  } deriving Show

-- | Given a file from a Manifest file, convert it into a more digestible 'HdlSource'
-- data structure. Supports all file types mentioned in 'SourceType'.
toHdlSource ::
  -- | Directory with HDL files
  FilePath ->
  -- | VHDL/SystemVerilog library name
  T.Text ->
  -- | Filename of file in directory given earlier
  FilePath ->
  -- | @Just HdlSource@ if file extension was recognized, otherwise @Nothing@
  Maybe HdlSource
toHdlSource dir lib filename
  | ".vhdl" `isSuffixOf` filename = go VhdlSource
  | ".v"    `isSuffixOf` filename = go VerilogSource
  | ".sv"   `isSuffixOf` filename = go SystemVerilogSource
  | ".tcl"  `isSuffixOf` filename = go TclSource
  | ".sdc"  `isSuffixOf` filename = go SdcSource
  | ".xdc"  `isSuffixOf` filename = go XdcSource
  | otherwise = Nothing
 where
  go ty = Just (HdlSource { hdlType=ty, hdlLib=lib, hdlFile=dir </> filename })

-- | Convert all generated files into 'HdlSource's for a given HDL directory and
-- corresponding 'Manifest'.
manifestToHdlSources :: LocatedManifest -> [HdlSource]
manifestToHdlSources manifest@LocatedManifest{lmManifest}=
  let
    paths = fst <$> fileNames lmManifest
    lib = topComponent lmManifest
  in
    mapMaybe (toHdlSource (entityDirectory manifest) lib) paths

-- | Mark inputs and outputs as false path, excluding clocks.
--
-- Note that this is fairly dangerous thing to do and should really only be used
-- in combination with 'Clash.Instances.Hacks.reducePins'. Even then, you should
-- make sure to synchronize any resets properly.
--
mkFalsePathXdc :: Manifest -> String
mkFalsePathXdc manifest = unlines (concatMap goPort (ports manifest))
 where
  goPort port =
    case (mpIsClock port, mpDirection port) of
      (True, _) -> []
      (False, In) -> [[__i|set_false_path -from [get_ports {#{mpName port}}]|]]
      (False, Out) -> [[__i|set_false_path -to [get_ports {#{mpName port}}]|]]
      (False, InOut) -> goPort port{mpDirection=In} <> goPort port{mpDirection=Out}

-- | Convert all generated files into 'HdlSource's for a given HDL directory and
-- corresponding 'Manifest's.
manifestsToHdlSources :: [LocatedManifest] -> [HdlSource]
manifestsToHdlSources = concatMap manifestToHdlSources

-- | Generates TCL that generates and reads Xilinx IP and reads constraints and
-- HDL files generated by Clash. The caller is responsible for starting synthesis
-- or simulation.
--
mkBaseTcl ::
  -- | Manifests of which the first is the top-level to synthesise
  NonEmpty LocatedManifest ->
  -- | Extra HDL source files to take into account
  [HdlSource] ->
  -- | Rendered TCL
  String
mkBaseTcl (topMan :| otherMans) extraFiles =
  [__i|
set_msg_config -severity {CRITICAL WARNING} -new_severity ERROR

source {#{tclDataFile}}

namespace eval tmpclash {}

|]

  ++ loadTclIfs

  ++ [__i|
create_project -in_memory
set tmpclash::ips [clash::runClashScripts]
if {$tmpclash::ips ne {}} {
  set tmpclash::ipFiles [get_property IP_FILE [get_ips $tmpclash::ips]]
}
close_project

if {$tmpclash::ips ne {}} {
  read_ip $tmpclash::ipFiles
  generate_target {synthesis simulation} [get_ips $tmpclash::ips]
}

|]

  ++ readSources
  ++ readConstraints

  ++ [__i|
\# Compiler doesn't topologically sort source files (bug)
update_compile_order -fileset [current_fileset]
|]
 where
  hdlSources = extraFiles <> manifestsToHdlSources (topMan : otherMans)
  cabalDir = unsafePerformIO getDataDir
  tclDataFile = cabalDir </> "data-files" </> "tcl" </> "clash_namespace.tcl"

  readConstraints =
    flip concatMap hdlSources $ \HdlSource{..} ->
      case hdlType of
        -- XXX: This reads EVERY constraint file from top. If a Clash design consists
        --      of multiple entities, this will fail.
        SdcSource -> [__i|read_xdc {#{hdlFile}}\n|]
        XdcSource -> [__i|read_xdc {#{hdlFile}}\n|]
        _ -> []

  loadTclIfs =
    flip concatMap hdlSources $ \HdlSource{..} ->
      case hdlType of
        TclSource -> [__i|clash::loadTclIface {#{hdlLib}} {#{hdlFile}}\n|]
        _ -> []

  readSources =
    flip concatMap hdlSources $ \HdlSource{..} ->
      case hdlType of
        VhdlSource ->
          [__i|read_vhdl -library {#{hdlLib}} {#{hdlFile}}\n|]
        VerilogSource ->
          [__i|read_verilog {#{hdlFile}}\n|]
        _ -> []

mkSynthesisTcl ::
  -- | Directory to write logs and checkpoints to
  FilePath ->
  -- | Out of context?
  Bool ->
  -- | Part to synthesize for. E.g., .
  String ->
  -- | Manifests of which the first is the top-level to synthesise
  NonEmpty LocatedManifest ->
  -- | Extra HDL source files to take into account
  [HdlSource] ->
  -- | Rendered TCL
  String
mkSynthesisTcl outputDir outOfContext part manifests extraFiles =
  mkBaseTcl manifests extraFiles <> "\n" <> [__i|
    file mkdir {#{outputDir </> "reports"}}
    file mkdir {#{outputDir </> "checkpoints"}}

    \# Synthesis
    synth_design -name #{name} -part #{part} -mode #{outOfContextStr}
    report_timing_summary -file {#{outputDir </> "reports" </> "post_synth_timing_summary.rpt"}}
    write_checkpoint -force {#{outputDir </> "checkpoints" </> "post_synth.dcp"}}


    \# Netlist
    file mkdir {#{outputDir </> "netlist"}}
    write_verilog -force {#{outputDir </> "netlist.v"}}
    write_xdc -no_fixed_only -force {#{outputDir </> "netlist.xdc"}}
  |]
 where
  name = topComponent lmManifest
  LocatedManifest{lmManifest} :| _ = manifests
  outOfContextStr
    | outOfContext = "out_of_context" :: String
    | otherwise    = "default"

mkPlaceTcl :: FilePath -> String
mkPlaceTcl outputDir = [__i|
    \# Pick up where synthesis left off
    open_checkpoint {#{outputDir </> "checkpoints" </> "post_synth.dcp"}}

    \# Run optimization & placement
    opt_design
    place_design
    phys_opt_design
    write_checkpoint -force {#{outputDir </> "checkpoints" </> "post_place.dcp"}}
    report_timing_summary -file {#{outputDir </> "reports" </> "post_place_timing_summary.rpt"}}
|]

mkRouteTcl :: FilePath -> String
mkRouteTcl outputDir = [__i|
    \# Pick up where placement left off
    open_checkpoint {#{outputDir </> "checkpoints" </> "post_place.dcp"}}

    \# Routing
    route_design
    write_checkpoint -force {#{outputDir </> "checkpoints" </> "post_route.dcp"}}
    report_timing_summary -file {#{outputDir </> "reports" </> "post_route_timing_summary.rpt"}}
    report_timing -sort_by group -max_paths 100 -path_type summary -file {#{outputDir </> "reports" </> "post_route_timing.rpt"}}

    report_clock_utilization -file {#{outputDir </> "reports" </> "post_route_clock_util.rpt"}}
    report_utilization       -file {#{outputDir </> "reports" </> "post_route_util.rpt"}}
    report_power             -file {#{outputDir </> "reports" </> "post_route_power.rpt"}}
    report_drc               -file {#{outputDir </> "reports" </> "post_route_drc.rpt"}}
|]

mkNetlistTcl :: FilePath -> String
mkNetlistTcl outputDir = [__i|
    \# Pick up where routing left off
    open_checkpoint {#{outputDir </> "checkpoints" </> "post_route.dcp"}}

    \# Generate netlist and constraints
    file mkdir {#{outputDir </> "netlist"}}
    write_verilog -force {#{outputDir </> "netlist.v"}}
    write_xdc -no_fixed_only -force {#{outputDir </> "netlist.xdc"}}
|]
