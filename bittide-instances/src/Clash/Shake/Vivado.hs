-- SPDX-FileCopyrightText: 2022-2023 Google LLC
--
-- SPDX-License-Identifier: Apache-2.0

{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}

-- | Generate a TCL script to simulate generated VHDL
--
-- Run with @vivado -mode batch -source ...@
--
module Clash.Shake.Vivado
  ( LocatedManifest(..)
  , mkFalsePathXdc
  , mkPlaceTcl
  , mkNetlistTcl
  , mkSynthesisTcl
  , mkRouteTcl
  , mkBitstreamTcl
  , mkBoardProgramTcl
  , meetsTiming
  ) where

import Prelude

import Clash.DataFiles (tclConnector)
import Clash.Driver.Manifest
import Data.List (isInfixOf)
import Data.String.Interpolate (__i)
import System.FilePath ((</>), dropFileName)

-- | Read a timing summary and determine whether it met timing.
meetsTiming :: FilePath -> IO Bool
meetsTiming reportPath = do
  reportContents <- readFile reportPath
  pure $ not ("Timing constraints are not met." `isInfixOf` reportContents)

-- TODO: Upstream
data LocatedManifest = LocatedManifest
  { -- | Path pointing to the manifest file itself
    lmPath :: FilePath

    -- | Manifest file corresponding to the one at 'lmPath'
  , lmManifest :: Manifest
  }

-- | Mark inputs and outputs as false path, excluding clocks.
--
-- Note that this is fairly dangerous thing to do and should really only be used
-- in combination with 'Clash.Instances.Hacks.reducePins'. Even then, you should
-- make sure to synchronize any resets properly.
--
mkFalsePathXdc :: Manifest -> String
mkFalsePathXdc manifest = unlines (concatMap goPort (ports manifest))
 where
  goPort port =
    case (mpIsClock port, mpDirection port) of
      (True, _) -> []
      (False, In) -> [[__i|set_false_path -from [get_ports {#{mpName port}}]|]]
      (False, Out) -> [[__i|set_false_path -to [get_ports {#{mpName port}}]|]]
      (False, InOut) -> goPort port{mpDirection=In} <> goPort port{mpDirection=Out}

-- | Generates TCL that generates and reads Xilinx IP and reads constraints and
-- HDL files generated by Clash. The caller is responsible for starting synthesis
-- or simulation.
--
mkBaseTcl ::
  -- | Where to create ip directory.
  FilePath ->
  -- | Top entity directory
  LocatedManifest ->
  -- | TCL script
  IO String
mkBaseTcl outputDir LocatedManifest{lmPath} = do
  connector <- tclConnector
  let topEntityDir = dropFileName lmPath

  pure [__i|
    set_msg_config -severity {CRITICAL WARNING} -new_severity ERROR
    source -notrace {#{connector}}
    file delete -force {#{outputDir </> "ip"}}
    file mkdir {#{outputDir </> "ip"}}
    clash::readMetadata {#{topEntityDir}}
    clash::createAndReadIp -dir {#{outputDir </> "ip"}}
    clash::readHdl
    clash::readXdc {early normal late}
    set_property TOP $clash::topEntity [current_fileset]
  |]

mkSynthesisTcl ::
  -- | Directory to write logs and checkpoints to
  FilePath ->
  -- | Out of context?
  Bool ->
  -- | Part to synthesize for. E.g., 'xcku040-ffva1156-2-e'.
  String ->
  -- | List of filepaths to XDC files
  [FilePath] ->
  -- | Manifests of which the first is the top-level to synthesize
  LocatedManifest ->
  -- | Rendered TCL
  IO String
mkSynthesisTcl outputDir outOfContext part constraints manifest@LocatedManifest{lmManifest} = do
  baseTcl <- mkBaseTcl outputDir manifest
  pure $ baseTcl <> "\n" <> [__i|
    set_msg_config -severity {CRITICAL WARNING} -new_severity ERROR

    #{constraintsString}
    file mkdir {#{outputDir </> "reports"}}
    file mkdir {#{outputDir </> "checkpoints"}}
    set_param synth.elaboration.rodinMoreOptions "rt::set_parameter var_size_limit 1000000000"
    \# Synthesis
    synth_design -name #{name} -part #{part} -mode #{outOfContextStr}
    report_timing_summary -file {#{outputDir </> "reports" </> "post_synth_timing_summary.rpt"}}
    report_utilization -file {#{outputDir </> "reports" </> "post_synth_util.rpt"}}
    write_checkpoint -force {#{outputDir </> "checkpoints" </> "post_synth.dcp"}}

    \# Netlist
    file mkdir {#{outputDir </> "netlist"}}
    write_verilog -force {#{outputDir </> "netlist" </> "netlist.v"}}
    write_xdc -no_fixed_only -force {#{outputDir </> "netlist" </> "netlist.xdc"}}
  |]
 where
  name = topComponent lmManifest
  outOfContextStr
    | outOfContext = "out_of_context" :: String
    | otherwise    = "default"
  constraintReader constr = "read_xdc {" <> constr <> "}\n"
  constraintsString = concatMap constraintReader constraints

mkPlaceTcl :: FilePath -> String
mkPlaceTcl outputDir = [__i|
    set_msg_config -severity {CRITICAL WARNING} -new_severity ERROR

    \# Pick up where synthesis left off
    open_checkpoint {#{outputDir </> "checkpoints" </> "post_synth.dcp"}}

    \# Place all clocks in individual clock groups and make them asynchronous
    set clkArgs {}
    foreach clk [get_clocks] {
      lappend clkArgs -group $clk
    }
    set_clock_groups -asynchronous {*}$clkArgs

    \# Run optimization & placement
    opt_design
    place_design
    phys_opt_design
    write_checkpoint -force {#{outputDir </> "checkpoints" </> "post_place.dcp"}}
    report_timing_summary -file {#{outputDir </> "reports" </> "post_place_timing_summary.rpt"}}
|]

mkRouteTcl :: FilePath -> String
mkRouteTcl outputDir = [__i|
    set_msg_config -severity {CRITICAL WARNING} -new_severity ERROR

    \# Pick up where placement left off
    open_checkpoint {#{outputDir </> "checkpoints" </> "post_place.dcp"}}

    \# Routing
    route_design
    write_checkpoint -force {#{outputDir </> "checkpoints" </> "post_route.dcp"}}
    report_timing_summary -file {#{outputDir </> "reports" </> "post_route_timing_summary.rpt"}}
    report_timing -sort_by group -max_paths 100 -path_type summary -file {#{outputDir </> "reports" </> "post_route_timing.rpt"}}

    report_clock_utilization -file {#{outputDir </> "reports" </> "post_route_clock_util.rpt"}}
    report_utilization       -file {#{outputDir </> "reports" </> "post_route_util.rpt"}}
    report_power             -file {#{outputDir </> "reports" </> "post_route_power.rpt"}}
    report_drc               -file {#{outputDir </> "reports" </> "post_route_drc.rpt"}}
|]

mkNetlistTcl :: FilePath -> String
mkNetlistTcl outputDir = [__i|
    set_msg_config -severity {CRITICAL WARNING} -new_severity ERROR

    \# Pick up where routing left off
    open_checkpoint {#{outputDir </> "checkpoints" </> "post_route.dcp"}}

    \# Generate netlist and constraints
    file mkdir {#{outputDir </> "netlist"}}
    write_verilog -force {#{outputDir </> "netlist" </> "netlist.v"}}
    write_xdc -no_fixed_only -force {#{outputDir </> "netlist" </> "netlist.xdc"}}
|]

mkBitstreamTcl :: FilePath -> String
mkBitstreamTcl outputDir = [__i|
    set_msg_config -severity {CRITICAL WARNING} -new_severity ERROR

    \# Pick up where routing left off
    open_checkpoint {#{outputDir </> "checkpoints" </> "post_route.dcp"}}

    \# Generate bitstream
    write_bitstream -force {#{outputDir </> "bitstream.bit"}}
    write_debug_probes -force {#{outputDir </> "probes.ltx"}}

    report_drc -file {#{outputDir </> "reports" </> "post_bitstream_drc.rpt"}}
|]

mkBoardProgramTcl :: FilePath -> String
mkBoardProgramTcl outputDir = [__i|
    set_msg_config -severity {CRITICAL WARNING} -new_severity ERROR

    \# Open the Hardware Manager and open the first board
    open_hw_manager
    connect_hw_server -url localhost:3121
    set target [lindex [get_hw_targets] 0]
    current_hw_target $target
    open_hw_target

    \# Set the current device to the first device in the JTAG chain
    set device [lindex [get_hw_devices] 0]
    current_hw_device $device
    set_property PROGRAM.FILE {#{outputDir </> "bitstream.bit"}} $device
    set_property PROBES.FILE {#{outputDir </> "probes.ltx"}} $device

    \# Program the device and close properly
    program_hw_devices $device
    refresh_hw_device $device
    close_hw_target
    close_hw_manager
|]
